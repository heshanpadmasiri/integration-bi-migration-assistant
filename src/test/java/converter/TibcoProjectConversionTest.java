/*
 *  Copyright (c) 2025, WSO2 LLC. (http://www.wso2.com). All Rights Reserved.
 *
 *  WSO2 LLC. licenses this file to you under the Apache License,
 *  Version 2.0 (the "License"); you may not use this file except
 *  in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an
 *  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 *  KIND, either express or implied.  See the License for the
 *  specific language governing permissions and limitations
 *  under the License.
 */

package converter;

import org.testng.Assert;
import org.testng.annotations.DataProvider;
import org.testng.annotations.Test;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Map;
import java.util.stream.Stream;

import static converter.MigrationTool.migrateTibcoProject;

public class TibcoProjectConversionTest {

    @Test(groups = {"tibco", "converter"}, dataProvider = "projectTestCaseProvider")
    public void testProjectConversion(Path tibcoProject, Path expectedBallerinaProject) throws IOException {
        // Create a temporary directory for the output
        Path tempDir = Files.createTempDirectory("tibco-conversion-test");
        try {
            // Run the conversion
            migrateTibcoProject(tibcoProject.toString(), tempDir.toString());

            // Compare the directories
            compareDirectories(tempDir, expectedBallerinaProject);
        } finally {
            // Clean up temporary directory
            deleteDirectory(tempDir);

            // Clear static state after test
            try {
                Class<?> contextClass = Class.forName("converter.tibco.analyzer.ModelAnalyser$ProcessAnalysisContext");
                java.lang.reflect.Field field = contextClass.getDeclaredField("activityFunctionNames");
                field.setAccessible(true);
                ((Map<?, ?>) field.get(null)).clear();
            } catch (Exception e) {
                throw new RuntimeException("Failed to clear activityFunctionNames", e);
            }
        }
    }

    private void compareDirectories(Path actual, Path expected) throws IOException {
        // First check if both directories exist
        Assert.assertTrue(Files.isDirectory(actual), "Actual path is not a directory: " + actual);
        Assert.assertTrue(Files.isDirectory(expected), "Expected path is not a directory: " + expected);

        // Compare directory contents
        try (Stream<Path> expectedFiles = Files.walk(expected);
             Stream<Path> actualFiles = Files.walk(actual)) {

            // Get relative paths for comparison, filtering only .bal files
            var expectedPaths = expectedFiles
                    .filter(Files::isRegularFile)
                    .filter(path -> path.toString().endsWith(".bal"))
                    .map(expected::relativize)
                    .toList();

            var actualPaths = actualFiles
                    .filter(Files::isRegularFile)
                    .filter(path -> path.toString().endsWith(".bal"))
                    .map(actual::relativize)
                    .toList();

            // Check if all expected .bal files exist
            for (Path relativePath : expectedPaths) {
                if (relativePath.endsWith("types.bal")) {
                    // Skip types.bal as it is generated and may differ
                    continue;
                }
                Assert.assertTrue(actualPaths.contains(relativePath),
                        "Missing .bal file in actual directory: " + relativePath);

                // Compare file contents
                Path expectedFile = expected.resolve(relativePath);
                Path actualFile = actual.resolve(relativePath);
                compareFiles(actualFile, expectedFile);
            }

            // Check for extra .bal files
            for (Path relativePath : actualPaths) {
                if (relativePath.endsWith("types.bal")) {
                    // Skip types.bal as it is generated and may differ
                    continue;
                }
                Assert.assertTrue(expectedPaths.contains(relativePath),
                        "Extra .bal file in actual directory: " + relativePath);
            }
        }
    }

    private void compareFiles(Path actual, Path expected) throws IOException {
        if (actual.toString().contains("types")) {
            // These are generated by XSD core and change from run to run
            return;
        }
        String actualContent = Files.readString(actual);
        String expectedContent = Files.readString(expected);
        Assert.assertEquals(actualContent, expectedContent,
                "File contents do not match for: " + actual.getFileName());
    }

    private void deleteDirectory(Path directory) throws IOException {
        if (Files.exists(directory)) {
            Files.walk(directory)
                    .sorted((a, b) -> -a.compareTo(b)) // Reverse order to delete files before directories
                    .forEach(path -> {
                        try {
                            Files.delete(path);
                        } catch (IOException e) {
                            throw new RuntimeException("Failed to delete: " + path, e);
                        }
                    });
        }
    }

    @DataProvider
    public Object[][] projectTestCaseProvider() throws IOException {
        Path projectTestCaseDir = Path.of("src", "test", "resources", "tibco.projects");
        Path expectedConvertedResultsDir = Path.of("src", "test", "resources", "tibco.projects.converted");

        // Get only the immediate directories (non-recursive)
        return Files.list(projectTestCaseDir)
                .filter(Files::isDirectory)
                .map(dir -> new Object[]{
                        dir,
                        expectedConvertedResultsDir.resolve(dir.getFileName())
                })
                .toArray(Object[][]::new);
    }
}
